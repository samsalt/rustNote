This document provides a structured overview of the `Box<T>` smart pointer in Rust, based on the content from the official Rust documentation.

## `Box<T>`: Pointing to Data on the Heap

In Rust, `Box<T>` is a smart pointer that allows you to store data on the heap instead of the stack. The pointer to the data on the heap is stored on the stack.

### Key Characteristics

  * **Heap Allocation**: `Box<T>` allocates memory on the heap for the data it contains.
  * **Known Size**: A `Box<T>` is a pointer, and its size is known at compile time, regardless of the size of the data it points to.
  * **Ownership**: A `Box<T>` has ownership of the data it points to. When the `Box<T>` goes out of scope, it is deallocated, and the data on the heap is also cleaned up. This is due to the implementation of the `Drop` trait.
  * **Dereferencing**: `Box<T>` implements the `Deref` trait, which allows it to be treated like a reference. This means you can access the data it points to using the `*` operator.

### Use Cases for `Box<T>`

You'll find `Box<T>` most useful in the following scenarios:

1.  **Recursive Types**: When you have a type whose size cannot be known at compile time. A common example is a recursive data structure like a cons list.
2.  **Large Data**: When you have a large amount of data and you want to transfer ownership without copying the data. By boxing the data, only the pointer is copied, which is much faster.
3.  **Trait Objects**: When you want to own a value and you only care that it's a type that implements a particular trait, not its specific type.

### Using `Box<T>` to Store Data on the Heap

Here's a simple example of how to use a `Box<T>` to store an `i32` value on the heap:

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

In this code, the value `5` is allocated on the heap, and `b` is a `Box` on the stack that points to it.

### Enabling Recursive Types with Boxes

A recursive type is a type that has another value of the same type as part of itself. Rust cannot determine the size of a recursive type at compile time, leading to a compilation error.

**Example: A Cons List**

A cons list is a data structure composed of nested pairs. Each item contains a value and a pointer to the next item. A naive implementation in Rust would be:

```rust,ignore
enum List {
    Cons(i32, List),
    Nil,
}
```

This code will not compile because the `List` type has an infinite size. To fix this, we can use a `Box<T>` to store the recursive part of the `enum`:

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
```

By using `Box<List>`, the `Cons` variant now stores a pointer to the next `List` value, rather than the value directly. This breaks the infinite recursion because the size of the pointer is known at compile time.
